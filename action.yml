name: Setup Fortran with Conda
description: Installs Fortran compilers and extra packages using Conda. Optionally builds and deploys FORD and/or Doxygen docs.
author: Seyed Ali Ghasemi
branding:
  icon: 'check'
  color: 'purple'

inputs:
  compiler:
    description: "Fortran compiler to install (gfortran, ifx, lfortran, flang, flang-new, nvfortran, mpifort)"
    required: false
    default: ""
  compiler-version:
    description: "compiler version"
    required: false
    default: ""
  platform:
    description: "Runner OS platform (ubuntu-latest, windows-latest, macos-latest)"
    required: false
    default: ""
  extra-packages:
    description: "List of additional Conda packages (e.g., cmake ninja)"
    required: false
    default: ""
  checkout-repo:
    description: "Whether to checkout the repository before setup"
    required: false
    default: "true"

  generate-doc-ford:
    description: "Whether to build and deploy FORD documentation"
    required: false
    default: "false"
  ford-config:
    description: "Path to FORD config file (e.g., README.md or ford.md)"
    required: false
    default: "README.md"
  ford-branch:
    description: "Branch to deploy FORD docs to"
    required: false
    default: "gh-pages-ford"
  ford-working-directory:
    description: "Directory to run FORD from (relative to root)"
    required: false
    default: "."
  ford-output-directory:
    description: "Path to generated FORD documentation (used by deployment)"
    required: false
    default: "doc/ford"
  ford-target-folder:
    description: "Target folder in repo for deployed FORD docs (used only if branch is main or master)"
    required: false
    default: "doc/ford"

  generate-doc-doxygen:
    description: "Whether to build and deploy Doxygen documentation"
    required: false
    default: "false"
  doxygen-config:
    description: "Path to Doxygen config file (e.g., Doxyfile)"
    required: false
    default: "Doxyfile"
  doxygen-branch:
    description: "Branch to deploy Doxygen docs to"
    required: false
    default: "gh-pages-doxygen"
  doxygen-working-directory:
    description: "Directory to run Doxygen from (relative to root)"
    required: false
    default: "."
  doxygen-output-directory:
    description: "Path to generated Doxygen documentation (used by deployment)"
    required: false
    default: "doc/doxygen"
  doxygen-target-folder:
    description: "Target folder in repo for deployed Doxygen docs (used only if branch is main or master)"
    required: false
    default: "doc/doxygen"

  generate-status-fpm:
    description: 'Generate STATUS.md for test_fpm jobs'
    required: false
    default: 'false'

  generate-status-cmake:
    description: 'Generate STATUS.md for test_cmake jobs'
    required: false
    default: 'false'

  generate-status-meson:
    description: 'Generate STATUS.md for test_meson jobs'
    required: false
    default: 'false'

  generate-status-table:
    description: "Generate and inject CI status table into README.md"
    required: false
    default: "false"

  update-readme-table:
    description: "Whether to auto-update the status table in README.md and commit it"
    required: false
    default: "false"
  update-readme-user-name:
    description: "Git user.name for README.md update commit"
    required: false
  update-readme-user-email:
    description: "Git user.email for README.md update commit"
    required: false
  update-readme-token:
    description: "GitHub token used to create the PR for updating the README table"
    required: false

  fortitude-check:
    description: "Run Fortitude check (https://github.com/PlasmaFAIR/fortitude)"
    required: false
    default: "false"
  fortitude-settings:
    description: "Extra flags for 'fortitude check'"
    required: false
    default: "--output-format github"

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      if: ${{ inputs.checkout-repo == 'true' || inputs.generate-doc-ford == 'true' || inputs.generate-doc-doxygen == 'true' }}
      uses: actions/checkout@v6.0.2

    - name: Setup Miniconda
      uses: conda-incubator/setup-miniconda@v3.3.0
      with:
        auto-update-conda: true
        activate-environment: fortran
        channels: conda-forge, defaults

    - name: Run Fortran compiler setup script
      if: ${{ inputs.compiler != '' && inputs.platform != '' }}
      shell: bash
      run: |
        node "${{ github.action_path }}/index.js"
      env:
        INPUT_COMPILER: ${{ inputs.compiler }}
        INPUT_COMPILER_VERSION: ${{ inputs.compiler-version }}
        INPUT_PLATFORM: ${{ inputs.platform }}
        INPUT_EXTRA_PACKAGES: ${{ inputs.extra-packages }}

    - name: Emit compiler version marker
      if: ${{ inputs.compiler != '' && inputs.platform != '' }}
      shell: bash
      run: |
        compiler="${{ inputs.compiler }}"
        case "$compiler" in
          flang-new|flang) compiler_bin="flang" ;;
          mpifort) compiler_bin="mpifort" ;;
          *) compiler_bin="$compiler" ;;
        esac

        version="$($compiler_bin --version 2>&1 | head -n 1 | tr -d '\r')"

        # Fallbacks for mpifort wrappers (Linux/macOS)
        if [[ -z "$version" && "$compiler" == "mpifort" ]]; then
          compiler_bin="$(mpifort -show 2>/dev/null | awk '{print $1}')"
          if [[ -n "$compiler_bin" ]]; then
            version="$($compiler_bin --version 2>&1 | head -n 1 | tr -d '\r')"
          else
            compiler_bin="$(mpifort --showme 2>/dev/null | awk '{print $1}')"
            if [[ -n "$compiler_bin" ]]; then
              version="$($compiler_bin --version 2>&1 | head -n 1 | tr -d '\r')"
            fi
          fi
        fi

        echo "COMPILER_VERSION=${compiler}|${version:-Unknown}"

    - name: Install and Run Fortitude Linter
      if: ${{ inputs.fortitude-check == 'true' }}
      shell: bash
      run: |
        source "${CONDA}/etc/profile.d/conda.sh"
        conda activate fortran

        echo "::group:: Installing Fortitude"
        pip install fortitude-lint
        echo "::endgroup::"

        echo "Running Fortitude with settings: ${{ inputs.fortitude-settings }}"
        fortitude check ${{ inputs.fortitude-settings }}

    - name: Build FORD documentation
      if: ${{ inputs.generate-doc-ford == 'true' }}
      shell: bash
      run: |
        source "${CONDA}/etc/profile.d/conda.sh"
        conda activate fortran
        echo "::group:: Setting up FORD documentation"
        conda install -y pip graphviz
        pip install ford
        mkdir -p "${{ inputs.ford-output-directory }}"
        cd "${{ inputs.ford-working-directory }}"
        echo "::endgroup::"
        ford "${{ inputs.ford-config }}"

    - name: Deploy FORD documentation
      if: ${{ inputs.generate-doc-ford == 'true' }}
      uses: JamesIves/github-pages-deploy-action@v4.8.0
      with:
        branch: ${{ inputs.ford-branch }}
        folder: ${{ inputs.ford-output-directory }}
        target-folder: ${{ inputs.ford-target-folder }}
        clean: ${{ !contains('main master', inputs.ford-branch) }}
        commit-message: "Deploy FORD docs"

    - name: Build Doxygen documentation
      if: ${{ inputs.generate-doc-doxygen == 'true' }}
      shell: bash
      run: |
        source "${CONDA}/etc/profile.d/conda.sh"
        conda activate fortran
        echo "::group:: Setting up Doxygen documentation"
        conda install -y graphviz doxygen
        mkdir -p "${{ inputs.doxygen-output-directory }}"
        cd "${{ inputs.doxygen-working-directory }}"
        echo "::endgroup::"
        doxygen "${{ inputs.doxygen-config }}"

    - name: Deploy Doxygen documentation
      if: ${{ inputs.generate-doc-doxygen == 'true' }}
      uses: JamesIves/github-pages-deploy-action@v4.8.0
      with:
        branch: ${{ inputs.doxygen-branch }}
        folder: ${{ inputs.doxygen-output-directory }}
        target-folder: ${{ inputs.doxygen-target-folder }}
        clean: ${{ !contains('main master', inputs.doxygen-branch) }}
        commit-message: "Deploy Doxygen docs"

    - name: Generate STATUS.md for test_fpm
      if: ${{ inputs.generate-status-fpm == 'true' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        REPO: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
      run: |
        echo "Waiting 60s to ensure all jobs are visible in GitHub API..."
        sleep 60

        echo "Generating STATUS.md for test_fpm..."
        badge_line=""

        short_version() {
          local v="$1"
          local sv
          sv="$(printf "%s" "$v" | grep -Eo '[0-9]+(\.[0-9]+){1,3}' | head -n 1)"
          [[ -z "$sv" ]] && sv="$(printf "%s" "$v" | awk '{print $1}')"
          echo "${sv:-unknown}"
        }

        get_version_for_job() {
          local job_id="$1"
          local zipfile line payload version
          zipfile="$(mktemp)"
          curl -sSL -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/${REPO}/actions/jobs/${job_id}/logs" \
            -o "$zipfile"
          line="$(unzip -p "$zipfile" 2>/dev/null | grep -m1 'COMPILER_VERSION=')"
          rm -f "$zipfile"
          payload="${line#*COMPILER_VERSION=}"
          version="${payload#*|}"
          short_version "$version"
        }

        mapfile -t job_lines < <(
          curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/jobs?per_page=100" \
            | jq -r '.jobs[] | select((.name | type == "string") and (.name | test(".*_fpm$"))) | [.id, .name, .conclusion] | @tsv'
        )

        for line in "${job_lines[@]}"; do
          IFS=$'\t' read -r job_id name conclusion <<< "$line"
          IFS='_' read -r os compiler jobtype <<< "$name"

          key="${os}_${compiler}"
          ver="$(get_version_for_job "$job_id")"
          key_with_ver="${key}_v${ver}"
          safe_key="${key_with_ver//-/'--'}"

          if [[ "$conclusion" == "success" ]]; then
            color="brightgreen"
            label="passing"
          elif [[ "$conclusion" == "failure" ]]; then
            color="red"
            label="failing"
          elif [[ "$conclusion" == "cancelled" ]]; then
            color="lightgrey"
            label="cancelled"
          else
            color="lightgrey"
            label="pending"
          fi

          badge="![${key_with_ver}](https://img.shields.io/badge/${safe_key}-${label}-${color})"
          badge_line="$badge_line $badge"
        done

        echo "$badge_line" > STATUS.md
        mkdir -p status-fpm
        mv STATUS.md status-fpm/STATUS.md
        cat status-fpm/STATUS.md

    - name: Deploy STATUS.md (test_fpm)
      if: ${{ inputs.generate-status-fpm == 'true' }}
      uses: JamesIves/github-pages-deploy-action@v4.8.0
      with:
        branch: status-fpm
        folder: status-fpm
        clean: true
        commit-message: "Deploy fpm status"

    - name: Generate STATUS.md for test_cmake
      if: ${{ inputs.generate-status-cmake == 'true' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        REPO: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
      run: |
        echo "Waiting 60s to ensure all jobs are visible in GitHub API..."
        sleep 60

        echo "Generating STATUS.md for test_cmake..."
        badge_line=""

        short_version() {
          local v="$1"
          local sv
          sv="$(printf "%s" "$v" | grep -Eo '[0-9]+(\.[0-9]+){1,3}' | head -n 1)"
          [[ -z "$sv" ]] && sv="$(printf "%s" "$v" | awk '{print $1}')"
          echo "${sv:-unknown}"
        }

        get_version_for_job() {
          local job_id="$1"
          local zipfile line payload version
          zipfile="$(mktemp)"
          curl -sSL -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/${REPO}/actions/jobs/${job_id}/logs" \
            -o "$zipfile"
          line="$(unzip -p "$zipfile" 2>/dev/null | grep -m1 'COMPILER_VERSION=')"
          rm -f "$zipfile"
          payload="${line#*COMPILER_VERSION=}"
          version="${payload#*|}"
          short_version "$version"
        }

        mapfile -t job_lines < <(
          curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/jobs?per_page=100" \
            | jq -r '.jobs[] | select((.name | type == "string") and (.name | test(".*_cmake$"))) | [.id, .name, .conclusion] | @tsv'
        )

        for line in "${job_lines[@]}"; do
          IFS=$'\t' read -r job_id name conclusion <<< "$line"
          IFS='_' read -r os compiler jobtype <<< "$name"

          key="${os}_${compiler}"
          ver="$(get_version_for_job "$job_id")"
          key_with_ver="${key}_v${ver}"
          safe_key="${key_with_ver//-/'--'}"

          if [[ "$conclusion" == "success" ]]; then
            color="brightgreen"
            label="passing"
          elif [[ "$conclusion" == "failure" ]]; then
            color="red"
            label="failing"
          elif [[ "$conclusion" == "cancelled" ]]; then
            color="lightgrey"
            label="cancelled"
          else
            color="lightgrey"
            label="pending"
          fi

          badge="![${key_with_ver}](https://img.shields.io/badge/${safe_key}-${label}-${color})"
          badge_line="$badge_line $badge"
        done

        echo "$badge_line" > STATUS.md
        mkdir -p status-cmake
        mv STATUS.md status-cmake/STATUS.md
        cat status-cmake/STATUS.md

    - name: Deploy STATUS.md (test_cmake)
      if: ${{ inputs.generate-status-cmake == 'true' }}
      uses: JamesIves/github-pages-deploy-action@v4.8.0
      with:
        branch: status-cmake
        folder: status-cmake
        clean: true
        commit-message: "Deploy cmake status"

    - name: Generate STATUS.md for test_meson
      if: ${{ inputs.generate-status-meson == 'true' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        REPO: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
      run: |
        echo "Waiting 60s to ensure all jobs are visible in GitHub API..."
        sleep 60

        echo "Generating STATUS.md for test_meson..."
        badge_line=""

        short_version() {
          local v="$1"
          local sv
          sv="$(printf "%s" "$v" | grep -Eo '[0-9]+(\.[0-9]+){1,3}' | head -n 1)"
          [[ -z "$sv" ]] && sv="$(printf "%s" "$v" | awk '{print $1}')"
          echo "${sv:-unknown}"
        }

        get_version_for_job() {
          local job_id="$1"
          local zipfile line payload version
          zipfile="$(mktemp)"
          curl -sSL -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/${REPO}/actions/jobs/${job_id}/logs" \
            -o "$zipfile"
          line="$(unzip -p "$zipfile" 2>/dev/null | grep -m1 'COMPILER_VERSION=')"
          rm -f "$zipfile"
          payload="${line#*COMPILER_VERSION=}"
          version="${payload#*|}"
          short_version "$version"
        }

        mapfile -t job_lines < <(
          curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/jobs?per_page=100" \
            | jq -r '.jobs[] | select((.name | type == "string") and (.name | test(".*_meson$"))) | [.id, .name, .conclusion] | @tsv'
        )

        for line in "${job_lines[@]}"; do
          IFS=$'\t' read -r job_id name conclusion <<< "$line"
          IFS='_' read -r os compiler jobtype <<< "$name"

          key="${os}_${compiler}"
          ver="$(get_version_for_job "$job_id")"
          key_with_ver="${key}_v${ver}"
          safe_key="${key_with_ver//-/'--'}"

          if [[ "$conclusion" == "success" ]]; then
            color="brightgreen"
            label="passing"
          elif [[ "$conclusion" == "failure" ]]; then
            color="red"
            label="failing"
          elif [[ "$conclusion" == "cancelled" ]]; then
            color="lightgrey"
            label="cancelled"
          else
            color="lightgrey"
            label="pending"
          fi

          badge="![${key_with_ver}](https://img.shields.io/badge/${safe_key}-${label}-${color})"
          badge_line="$badge_line $badge"
        done

        echo "$badge_line" > STATUS.md
        mkdir -p status-meson
        mv STATUS.md status-meson/STATUS.md
        cat status-meson/STATUS.md

    - name: Deploy STATUS.md (test_meson)
      if: ${{ inputs.generate-status-meson == 'true' }}
      uses: JamesIves/github-pages-deploy-action@v4.8.0
      with:
        branch: status-meson
        folder: status-meson
        clean: true
        commit-message: "Deploy meson status"

    - name: Generate and Inject CI Matrix into README
      if: ${{ inputs.generate-status-table == 'true' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        REPO: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
      run: |
        bash "${{ github.action_path }}/scripts/update-readme-status.sh"

    - name: Checkout repository (for README update)
      if: ${{ inputs.update-readme-table == 'true' }}
      uses: actions/checkout@v6.0.2
      with:
        persist-credentials: false

    - name: Generate status table in README
      if: ${{ inputs.update-readme-table == 'true' }}
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        REPO: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
      run: |
        bash "${{ github.action_path }}/scripts/update-readme-status.sh"

    - name: Setup Git author
      if: ${{ inputs.update-readme-table == 'true' }}
      shell: bash
      run: |
        git config user.name "${{ inputs.update-readme-user-name }}"
        git config user.email "${{ inputs.update-readme-user-email }}"

    - name: Create Pull Request for README table
      if: ${{ inputs.update-readme-table == 'true' }}
      uses: peter-evans/create-pull-request@v8.1.0
      with:
        token: "${{ inputs.update-readme-token }}"
        commit-message: "Update README.md status table [ci skip]"
        branch: update/readme-status-table
        title: "update README.md status table"
        body: "This PR updates the CI status table in the README.md."
        delete-branch: true