var tipuesearch = {"pages":[{"title":" test ","text":"test Setup Fortran with Conda A GitHub Action that sets up a Fortran development environment using Conda. Inspired by Conda + Fortran . Supported Compiler Configurations The selected Fortran compiler is installed along with the corresponding C and C++ compilers, as well as fpm , cmake , ninja and meson . Additional packages can be installed using the extra-packages input. Ubuntu Fortran Compiler C Compiler C++ Compiler gfortran gcc g++ ifx icx icx lfortran gcc g++ flang, flang-new clang clang++ nvfortran nvc nvc++ macOS Fortran Compiler C Compiler C++ Compiler gfortran gcc g++ lfortran clang clang++ Windows Fortran Compiler C Compiler C++ Compiler gfortran gcc g++ ifx icx icx lfortran clang-cl clang-cl flang, flang-new clang-cl clang-cl The following environment variables are automatically set: FC , CC , CXX FPM_FC , FPM_CC , FPM_CXX CMAKE_Fortran_COMPILER , CMAKE_C_COMPILER , CMAKE_CXX_COMPILER Simple Usage name : Setup Fortran Conda CI/CD on : [ push ] permissions : contents : write jobs : test_fpm : name : ${{ matrix.os }}_${{ matrix.compiler }}_fpm runs-on : ${{ matrix.os }} matrix : os : [ ubuntu-latest , macos-latest , windows-latest ] compiler : [ gfortran , ifx , lfortran , flang-new , nvfortran ] exclude : - os : macos-latest compiler : flang-new - os : macos-latest compiler : ifx - os : macos-latest compiler : nvfortran - os : windows-latest compiler : nvfortran steps : - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} platform : ${{ matrix.os }} - name : fpm test (debug) run : fpm test --compiler ${{ matrix.compiler }} --profile debug - name : fpm test (release) run : fpm test --compiler ${{ matrix.compiler }} --profile release ‚úÖ CI Status Compiler macos ubuntu windows flang-new - fpm ‚úÖ  cmake ‚úÖ  meson ‚úÖ fpm ‚ùå  cmake ‚úÖ gfortran fpm ‚úÖ  cmake ‚úÖ fpm ‚úÖ  cmake ‚úÖ  meson ‚úÖ fpm ‚úÖ  cmake ‚úÖ ifx - fpm ‚úÖ  cmake ‚úÖ  meson ‚úÖ fpm ‚úÖ  cmake ‚úÖ lfortran fpm ‚úÖ  cmake ‚úÖ fpm ‚úÖ  cmake ‚úÖ fpm ‚úÖ  cmake ‚ùå mpifort mpi_fpm ‚úÖ mpi_fpm ‚úÖ - nvfortran - fpm ‚úÖ  cmake ‚úÖ - STATUS.md (FPM) STATUS.md (CMake) STATUS.md (Meson) üìã Workflow Example üîê IMPORTANT NOTES ‚ö†Ô∏è Use your own name and email! Don‚Äôt copy the example values. To enable automatic updates to the CI status table in README.md via the update_readme_table job: Create a GitHub Personal Access Token (PAT) with repo scope. Add it to your repo secrets, e.g. GH_PAT . Configure these inputs: update-readme-token : ${{ secrets.GH_PAT }} update-readme-user-name : \"Your Name\" update-readme-user-email : \"you@example.com\" üí° Tip: When integrating CI/CD, testing often requires multiple commits and iterations.\nTo keep your main branch clean, consider using a separate branch (e.g., dev ) for development and testing. Once everything is working, you can merge it into main. You can include only the jobs you need in your workflow. This example includes all available jobs to demonstrate a comprehensive CI/CD setup. Overview This example automates Fortran CI/CD: üì¶ Fortran compiler setup : Supports: gfortran , ifx , lfortran , flang-new , nvfortran üñ•Ô∏è Cross-platform testing : Ubuntu, Windows, macOS GitHub runners üß™ Testing : fpm test with debug and release profiles CMake with Ninja and CTest Meson with Ninja üìÑ Documentation : FORD Doxygen üìä Status Reporting : Auto-generates STATUS.md for fpm / cmake / meson test results Injects summary into README.md creates PRs to update the status table in README.md üßπ Linting : Runs Fortitude check README Integration To enable automatic CI status table injection, add the following to your README.md : <!-- STATUS:setup-fortran-conda:START -->\n<!-- STATUS:setup-fortran-conda:END --> Job Breakdown Job Name Description test_fpm Run fpm tests (debug + release) for each OS/compiler test_cmake Run CMake/Ninja builds and tests test_meson Run Meson builds and tests doc_ford Build and deploy FORD-generated docs doc_doxygen Build and deploy Doxygen-generated docs status_fpm Generate STATUS.md with fpm test results status_cmake Generate STATUS.md with cmake test results status_meson Generate STATUS.md with meson test results update_readme_table Inject CI summary table into README.md and open a pull request linter_fortitude Run Fortitude linter modify this example workflow file to your needs, and save it as .github/workflows/CI-CD.yml in your repository: name : Setup Fortran Conda CI/CD on : push : branches : [ main , master , dev ] permissions : contents : write jobs : # Run FPM tests (debug + release) on all OS/compiler combinations test_fpm : name : ${{ matrix.os }}_${{ matrix.compiler }}_fpm runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ ubuntu-latest , macos-latest , windows-latest ] compiler : [ gfortran , ifx , lfortran , flang-new , nvfortran ] include : - os : ubuntu-latest extra-packages : \"\" - os : windows-latest extra-packages : \"\" - os : macos-latest extra-packages : \"\" exclude : - os : macos-latest compiler : flang-new - os : macos-latest compiler : ifx - os : macos-latest compiler : nvfortran - os : windows-latest compiler : nvfortran steps : - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} - name : fpm test (debug) run : fpm test --compiler ${{ matrix.compiler }} --profile debug --verbose - name : fpm test (release) run : fpm test --compiler ${{ matrix.compiler }} --profile release --verbose # Run CMake + Ninja build/tests across OS/compiler matrix test_cmake : name : ${{ matrix.os }}_${{ matrix.compiler }}_cmake runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ ubuntu-latest , macos-latest , windows-latest ] compiler : [ gfortran , ifx , lfortran , flang-new , nvfortran ] include : - os : ubuntu-latest extra-packages : \"\" - os : windows-latest extra-packages : \"\" - os : macos-latest extra-packages : \"\" exclude : - os : macos-latest compiler : flang-new - os : macos-latest compiler : ifx - os : macos-latest compiler : nvfortran - os : windows-latest compiler : nvfortran steps : - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} - name : cmake test (debug) run : | cmake -S . -B build/debug -DCMAKE_BUILD_TYPE=Debug -DCMAKE_Fortran_COMPILER=${{ matrix.compiler }} -G Ninja cmake --build build/debug ctest --test-dir build/debug --output-on-failure - name : cmake test (release) run : | cmake -S . -B build/release -DCMAKE_BUILD_TYPE=Release -DCMAKE_Fortran_COMPILER=${{ matrix.compiler }} -G Ninja cmake --build build/release ctest --test-dir build/release --output-on-failure # Run Meson builds and tests across OS/compiler matrix test_meson : name : ${{ matrix.os }}_${{ matrix.compiler }}_meson runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ ubuntu-latest , macos-latest , windows-latest ] compiler : [ gfortran , ifx , lfortran , flang-new , nvfortran ] include : - os : ubuntu-latest extra-packages : \"\" - os : windows-latest extra-packages : \"\" - os : macos-latest extra-packages : \"\" exclude : - os : macos-latest compiler : flang-new - os : macos-latest compiler : ifx - os : macos-latest compiler : nvfortran - os : windows-latest compiler : nvfortran steps : - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} - name : meson test (debug) run : | meson setup --wipe build/meson/debug --buildtype debug --backend=ninja meson compile -C build/meson/debug --verbose meson test -C build/meson/debug --verbose - name : meson test (release) run : | meson setup --wipe build/meson/release --buildtype release --backend=ninja meson compile -C build/meson/release --verbose meson test -C build/meson/release --verbose # Build and deploy FORD documentation doc_ford : name : Generate FORD Documentation runs-on : ubuntu-latest steps : - name : Setup and Generate FORD Documentation uses : gha3mi/setup-fortran-conda@latest with : compiler : gfortran generate-doc-ford : true ford-working-directory : . ford-config : README.md ford-output-directory : doc/ford ford-branch : gh-pages-ford ford-target-folder : doc/ford # Build and deploy Doxygen documentation doc_doxygen : name : Generate Doxygen Documentation runs-on : ubuntu-latest steps : - name : Setup and Generate Doxygen Documentation uses : gha3mi/setup-fortran-conda@latest with : compiler : gfortran generate-doc-doxygen : true doxygen-working-directory : . doxygen-config : Doxyfile doxygen-output-directory : doc/doxygen doxygen-branch : gh-pages-doxygen doxygen-target-folder : doc/doxygen # Generate STATUS.md from FPM job results status_fpm : name : Generate STATUS.md if : always() needs : test_fpm runs-on : ubuntu-latest steps : - name : Generate summary uses : gha3mi/setup-fortran-conda@latest with : generate-status-fpm : true # Generate STATUS.md from CMake job results status_cmake : name : Generate STATUS.md if : always() needs : test_cmake runs-on : ubuntu-latest steps : - name : Generate summary uses : gha3mi/setup-fortran-conda@latest with : generate-status-cmake : true # Generate STATUS.md from Meson job results status_meson : name : Generate STATUS.md if : always() needs : test_meson runs-on : ubuntu-latest steps : - name : Generate summary uses : gha3mi/setup-fortran-conda@latest with : generate-status-meson : true # Inject CI status table into README.md update_readme_table : name : Update README.md status table if : | always() && github.ref != 'refs/heads/update-readme-table' needs : [ status_fpm , status_cmake ] runs-on : ubuntu-latest steps : - name : Update README status uses : gha3mi/setup-fortran-conda@latest with : update-readme-table : true update-readme-token : ${{ secrets.GH_PAT }} # Update with your GitHub personal access token update-readme-user-name : \"Your Name\" # Update with your name update-readme-user-email : \"you@example.com\" # Update with your email # Run Fortran linter with Fortitude linter_fortitude : name : Run Fortitude Linter runs-on : ubuntu-latest steps : - name : Run Fortitude Linter uses : gha3mi/setup-fortran-conda@latest with : fortitude-check : true fortitude-settings : \"--output-format github\" Specifying Compiler Versions By default, the above example installs the latest available versions of each compiler.\nTo use a specific version, add a compiler-version entry in your matrix: matrix :\n  # os : [ ubuntu - latest , macos - latest , windows - latest ]\n  # compiler : [ gfortran , ifx , lfortran , flang - new , nvfortran ] include :\n    # gfortran - os : ubuntu - latest compiler : gfortran compiler - version : 15 . 1 . 0 extra - packages : \"\" - os : macos - latest compiler : gfortran compiler - version : 15 . 1 . 0 extra - packages : \"\" - os : windows - latest compiler : gfortran compiler - version : 15 . 1 . 0 extra - packages : \"\" Then, reference compiler-version in the setup step: - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} compiler-version : ${{ matrix.compiler-version }} # must be specified platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} If compiler-version is set to an empty string \"\" , the latest version will be installed. MPI Support MPI-based tests can be executed using fpm with the mpifort. This is currently supported on Linux and macOS runners. The following example job sets up the environment and runs parallel MPI tests: test_mpi_fpm : name : ${{ matrix . os }} _ ${{ matrix . compiler }} _mpi_fpm runs - on : ${{ matrix . os }} strategy : fail - fast : false matrix : os : [ ubuntu-latest, macos-latest ] compiler : [ mpifort ] include : - os : ubuntu - latest extra - packages : \"\" - os : macos - latest extra - packages : \"\" steps : - name : Setup Fortran uses : gha3mi / setup - fortran - conda @latest with : compiler : ${{ matrix . compiler }} platform : ${{ matrix . os }} extra - packages : ${{ matrix . extra - packages }} - name : fpm test ( debug ) run : fpm test -- target mpi_hello -- compiler ${{ matrix . compiler }} -- profile debug -- flag \"-cpp -DUSE_MPI\" -- runner \"mpirun -np 4\" -- verbose - name : fpm test ( release ) run : fpm test --target mpi_hello --compiler ${{ matrix.compiler }} --profile release --flag \"-cpp -DUSE_MPI\" --runner \"mpirun -np 4\" --verbose üöÄ Release Automation This project includes a Bash script for automating GitHub releases. curl -L https://raw.githubusercontent.com/gha3mi/setup-fortran-conda/main/release.sh -o release.sh Features The script automates: ‚úÖ Semantic versioning : Calculates the next version ( major , minor , or patch ) based on PR titles and commit messages. üìù CHANGELOG generation : Compiles a categorized CHANGELOG.md using PR data and commits since the last release. üîñ Git tagging : Tags the new version (e.g., v1.2.3 ) and updates the floating latest tag. üì§ GitHub Release : Publishes a release with autogenerated notes. üíª Modes : --dry-run : Simulates the release steps with no side effects. --local : Updates files and tags locally, but skips pushing or publishing the release. Requirements GitHub CLI ( gh ) ‚Äì must be authenticated ( gh auth login ) jq Usage bash release.sh --help Recommended Workflow It‚Äôs highly recommended to first run in --dry-run mode to verify the output. üîó See Also fortran-lang/setup-fortran https://degenerateconic.com/conda-plus-fortran.html Fortran Discourse: GitHub Action: Setup Fortran with Conda Fortran Discourse: Simple CI with Conda Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"say_hello ‚Äì test","text":"public  subroutine say_hello() Arguments None Called by proc~~say_hello~~CalledByGraph proc~say_hello say_hello program~check check program~check->proc~say_hello Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/say_hello.html"},{"title":"main ‚Äì test","text":"Used by module~~main~~UsedByGraph module~main main program~check check program~check->module~main Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine say_hello () Arguments None","tags":"","url":"module/main.html"},{"title":"mpi_hello ‚Äì test","text":"","tags":"","url":"program/mpi_hello.html"},{"title":"check ‚Äì test","text":"Uses main program~~check~~UsesGraph program~check check module~main main program~check->module~main Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~check~~CallsGraph program~check check proc~say_hello say_hello program~check->proc~say_hello Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"program/check.html"},{"title":"main.f90 ‚Äì test","text":"Files dependent on this one sourcefile~~main.f90~~AfferentGraph sourcefile~main.f90 main.f90 sourcefile~check.f90 check.f90 sourcefile~check.f90->sourcefile~main.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module main implicit none private public :: say_hello contains subroutine say_hello print * , \"Hello World!\" end subroutine end module","tags":"","url":"sourcefile/main.f90.html"},{"title":"mpi_hello.F90 ‚Äì test","text":"Source Code program mpi_hello #if defined(USE_MPI) use mpi_f08 implicit none integer :: ierr , rank , size call mpi_init ( ierr ) call mpi_comm_rank ( mpi_comm_world , rank , ierr ) call mpi_comm_size ( mpi_comm_world , size , ierr ) print * , 'hello from process' , rank , 'of' , size call mpi_finalize ( ierr ) #endif end program","tags":"","url":"sourcefile/mpi_hello.f90.html"},{"title":"check.f90 ‚Äì test","text":"This file depends on sourcefile~~check.f90~~EfferentGraph sourcefile~check.f90 check.f90 sourcefile~main.f90 main.f90 sourcefile~check.f90->sourcefile~main.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program check use main implicit none call say_hello () end program","tags":"","url":"sourcefile/check.f90.html"}]}