var tipuesearch = {"pages":[{"title":" test ","text":"test Setup Fortran with Conda A GitHub Action that sets up a Fortran development environment using Conda. Inspired by Conda + Fortran . 📋 Workflow Example 🔐 IMPORTANT NOTES ⚠️ Use your own name and email! Don’t copy the example values. To enable automatic updates to the CI status table in README.md via the update_readme_table job: Create a GitHub Personal Access Token (PAT) with repo scope. Add it to your repo secrets, e.g. GH_PAT . Configure these inputs: update-readme-token : ${{ secrets.GH_PAT }} update-readme-user-name : \"Your Name\" update-readme-user-email : \"you@example.com\" 💡 Tip: When integrating CI/CD, testing often requires multiple commits and iterations.\nTo keep your main branch clean, consider using a separate branch (e.g., dev ) for development and testing. Once everything is working, you can merge it into main. You can include only the jobs you need in your workflow. This example includes all available jobs to demonstrate a comprehensive CI/CD setup. Overview This example automates Fortran CI/CD: 📦 Fortran compiler setup : Supports: gfortran , ifx , lfortran , flang-new , nvfortran 🖥️ Cross-platform testing : Ubuntu, Windows, macOS GitHub runners 🧪 Testing : fpm test with debug and release profiles CMake with Ninja and CTest 📄 Documentation : FORD Doxygen 📊 Status Reporting : Auto-generates STATUS.md for fpm / cmake test results Injects summary into README.md creates PRs to update the status table in README.md 🧹 Linting : Runs Fortitude check README Integration To enable automatic CI status table injection, add the following to your README.md : <!-- STATUS:setup-fortran-conda:START -->\n<!-- STATUS:setup-fortran-conda:END --> Job Breakdown Job Name Description test_fpm Run fpm tests (debug + release) for each OS/compiler test_cmake Run CMake/Ninja builds and tests doc_ford Build and deploy FORD-generated docs doc_doxygen Build and deploy Doxygen-generated docs status_fpm Generate STATUS.md with fpm test results status_cmake Generate STATUS.md with cmake test results update_readme_table Inject CI summary table into README.md and open a pull request linter_fortitude Run Fortitude linter modify this example workflow file to your needs, and save it as .github/workflows/CI-CD.yml in your repository: name : Setup Fortran Conda CI/CD on : push : branches : [ main , master , dev ] pull_request : branches : [ main , master ] permissions : contents : write pull-requests : write jobs : # Run FPM tests (debug + release) on all OS/compiler combinations test_fpm : name : ${{ matrix.os }}_${{ matrix.compiler }}_fpm runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ ubuntu-latest , macos-latest , windows-latest ] compiler : [ gfortran , ifx , lfortran , flang-new , nvfortran ] include : - os : ubuntu-latest extra-packages : \"\" - os : windows-latest extra-packages : \"\" - os : macos-latest extra-packages : \"\" exclude : - os : macos-latest compiler : flang-new - os : macos-latest compiler : ifx - os : macos-latest compiler : nvfortran - os : windows-latest compiler : nvfortran steps : - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} - name : fpm test (debug) run : fpm test --compiler ${{ matrix.compiler }} --profile debug --verbose - name : fpm test (release) run : fpm test --compiler ${{ matrix.compiler }} --profile release --verbose # Run CMake + Ninja build/tests across OS/compiler matrix test_cmake : name : ${{ matrix.os }}_${{ matrix.compiler }}_cmake runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ ubuntu-latest , macos-latest , windows-latest ] compiler : [ gfortran , ifx , lfortran , flang-new , nvfortran ] include : - os : ubuntu-latest extra-packages : \"cmake, ninja\" - os : windows-latest extra-packages : \"cmake, ninja\" - os : macos-latest extra-packages : \"cmake, ninja\" exclude : - os : macos-latest compiler : flang-new - os : macos-latest compiler : ifx - os : macos-latest compiler : nvfortran - os : windows-latest compiler : nvfortran steps : - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} - name : cmake test (debug) run : | cmake -S . -B build/debug -DCMAKE_BUILD_TYPE=Debug -DCMAKE_Fortran_COMPILER=${{ matrix.compiler }} -G Ninja cmake --build build/debug ctest --test-dir build/debug --output-on-failure - name : cmake test (release) run : | cmake -S . -B build/release -DCMAKE_BUILD_TYPE=Release -DCMAKE_Fortran_COMPILER=${{ matrix.compiler }} -G Ninja cmake --build build/release ctest --test-dir build/release --output-on-failure # Build and deploy FORD documentation doc_ford : name : Generate FORD Documentation runs-on : ubuntu-latest steps : - name : Setup and Generate FORD Documentation uses : gha3mi/setup-fortran-conda@latest with : compiler : gfortran generate-doc-ford : true ford-working-directory : . ford-config : README.md ford-output-directory : doc/ford ford-branch : gh-pages-ford ford-target-folder : doc/ford # Build and deploy Doxygen documentation doc_doxygen : name : Generate Doxygen Documentation runs-on : ubuntu-latest steps : - name : Setup and Generate Doxygen Documentation uses : gha3mi/setup-fortran-conda@latest with : compiler : gfortran generate-doc-doxygen : true doxygen-working-directory : . doxygen-config : Doxyfile doxygen-output-directory : doc/doxygen doxygen-branch : gh-pages-doxygen doxygen-target-folder : doc/doxygen # Generate STATUS.md from FPM job results status_fpm : name : Generate STATUS.md if : always() needs : test_fpm runs-on : ubuntu-latest steps : - name : Generate summary uses : gha3mi/setup-fortran-conda@latest with : generate-status-fpm : true # Generate STATUS.md from CMake job results status_cmake : name : Generate STATUS.md if : always() needs : test_cmake runs-on : ubuntu-latest steps : - name : Generate summary uses : gha3mi/setup-fortran-conda@latest with : generate-status-cmake : true # Inject CI status table into README.md update_readme_table : name : Update README.md status table if : | always() && github.ref != 'refs/heads/update-readme-table' needs : [ status_fpm , status_cmake ] runs-on : ubuntu-latest steps : - name : Update README status uses : gha3mi/setup-fortran-conda@latest with : update-readme-table : true update-readme-token : ${{ secrets.GH_PAT }} # Update with your GitHub personal access token update-readme-user-name : \"Your Name\" # Update with your name update-readme-user-email : \"you@example.com\" # Update with your email # Run Fortran linter with Fortitude linter_fortitude : name : Run Fortitude Linter runs-on : ubuntu-latest steps : - name : Run Fortitude Linter uses : gha3mi/setup-fortran-conda@latest with : fortitude-check : true fortitude-settings : \"--output-format github\" Specifying Compiler Versions By default, the above example installs the latest available versions of each compiler.\nTo use a specific version, add a compiler-version entry in your matrix: matrix :\n  # os : [ ubuntu - latest , macos - latest , windows - latest ]\n  # compiler : [ gfortran , ifx , lfortran , flang - new , nvfortran ] include :\n    # gfortran - os : ubuntu - latest compiler : gfortran compiler - version : 15 . 1 . 0 extra - packages : \" cmake, ninja \" - os : macos - latest compiler : gfortran compiler - version : 15 . 1 . 0 extra - packages : \" cmake, ninja \" - os : windows - latest compiler : gfortran compiler - version : 15 . 1 . 0 extra - packages : \" cmake, ninja \" Then, reference compiler-version in the setup step: - name : Setup Fortran uses : gha3mi/setup-fortran-conda@latest with : compiler : ${{ matrix.compiler }} compiler-version : ${{ matrix.compiler-version }} # must be specified platform : ${{ matrix.os }} extra-packages : ${{ matrix.extra-packages }} If compiler-version is set to an empty string \"\" , the latest version will be installed. ✅ Status Compiler macos ubuntu windows flang-new - fpm ✅  cmake ✅ fpm ❌  cmake ✅ gfortran fpm ✅  cmake ✅ fpm ✅  cmake ✅ fpm ✅  cmake ✅ ifx - fpm ✅  cmake ✅ fpm ✅  cmake ✅ lfortran fpm ✅  cmake ✅ fpm ✅  cmake ✅ fpm ✅  cmake ✅ nvfortran - fpm ✅  cmake ✅ - STATUS.md (FPM) STATUS.md (CMake) 🔗 See Also fortran-lang/setup-fortran https://degenerateconic.com/conda-plus-fortran.html Fortran Discourse: GitHub Action: Setup Fortran with Conda Fortran Discourse: Simple CI with Conda Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"say_hello – test","text":"public  subroutine say_hello() Arguments None Called by proc~~say_hello~~CalledByGraph proc~say_hello say_hello program~check check program~check->proc~say_hello Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/say_hello.html"},{"title":"main – test","text":"Used by module~~main~~UsedByGraph module~main main program~check check program~check->module~main Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine say_hello () Arguments None","tags":"","url":"module/main.html"},{"title":"check – test","text":"Uses main program~~check~~UsesGraph program~check check module~main main program~check->module~main Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~check~~CallsGraph program~check check proc~say_hello say_hello program~check->proc~say_hello Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"program/check.html"},{"title":"mpi_hello – test","text":"Uses mpi_f08 program~~mpi_hello~~UsesGraph program~mpi_hello mpi_hello mpi_f08 mpi_f08 program~mpi_hello->mpi_f08 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~mpi_hello~~CallsGraph program~mpi_hello mpi_hello mpi_comm_rank mpi_comm_rank program~mpi_hello->mpi_comm_rank mpi_comm_size mpi_comm_size program~mpi_hello->mpi_comm_size mpi_finalize mpi_finalize program~mpi_hello->mpi_finalize mpi_init mpi_init program~mpi_hello->mpi_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: ierr integer :: rank integer :: size","tags":"","url":"program/mpi_hello.html"},{"title":"check.f90 – test","text":"This file depends on sourcefile~~check.f90~~EfferentGraph sourcefile~check.f90 check.f90 sourcefile~main.f90 main.f90 sourcefile~check.f90->sourcefile~main.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program check use main implicit none call say_hello () end program","tags":"","url":"sourcefile/check.f90.html"},{"title":"mpi_hello.f90 – test","text":"Source Code program mpi_hello use mpi_f08 implicit none integer :: ierr , rank , size call mpi_init ( ierr ) call mpi_comm_rank ( mpi_comm_world , rank , ierr ) call mpi_comm_size ( mpi_comm_world , size , ierr ) print * , 'hello from process' , rank , 'of' , size call mpi_finalize ( ierr ) end program","tags":"","url":"sourcefile/mpi_hello.f90.html"},{"title":"main.f90 – test","text":"Files dependent on this one sourcefile~~main.f90~~AfferentGraph sourcefile~main.f90 main.f90 sourcefile~check.f90 check.f90 sourcefile~check.f90->sourcefile~main.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module main implicit none private public :: say_hello contains subroutine say_hello print * , \"Hello World!\" end subroutine end module","tags":"","url":"sourcefile/main.f90.html"}]}